#lang plai

;; ***********************************
;; *** START OF FILE WRITER MODULE ***
;; ***********************************

(define start "<!DOCTYPE html>\n<html>\n\t<head>\n\t</head>\n\t<body>\n")
(define end "\t</body>\n</html>")

;; create-html-file : () -> port
;; Produces a port to a new file sample.html
;; TODO: Allow an argument to be supplied to this that allows a user to modify the file name
(define (create-html-file)
  (open-output-file "test/sample.html" #:mode 'text #:exists 'can-update))

;; write-start-html-to-output-file : port -> port
;; Writes the starting string 'start to the given port and returns the given port
(define (write-start-html-to-output-file output-file)
  (begin
    (display start output-file)
    output-file))

;; write-body-to-output-file : string port -> port
;; Writes the given html body generated by our logic to the given port and returns the given port
(define (write-body-to-output-file generated-html-string output-file)
  (begin
    (display generated-html-string output-file)
    output-file))

;; write-end-html-to-output-file : port -> port
;; Writes the starting string 'start to the given port and returns the given port
(define (write-end-html-to-output-file output-file)
  (begin
    (display end output-file)
    output-file))

;; ***********************************
;; *** START OF FILE READER MODULE ***
;; ***********************************

;; get-input-file : port -> string
;; Produces a port to the user input file
(define (get-input-file)
  (open-input-file "test/sample.txt" #:mode 'text))

;; read-user-input : port -> string
;; Produces a port to the user input file
(define (read-user-input input-file)
  (read-line input-file))

;; ***********************************
;; *** START OF INTERPRETER MODULE ***
;; ***********************************

(define-type exp
  [create-paragraph (t string?)])

;; extract-text-from-create-paragraph-call : string -> string
;; Returns only the text in a create paragraph statement
(define (extract-text-from-create-paragraph-call call)
  (rest (rest (string-split call " "))))

;; build-string-w-spaces : string string -> string
;; Adds the first given string to the second given string with a space in between
(define (build-string-w-spaces s acc)
  (string-append acc (string-append " " s)))

;; parse : any -> exp
(define (parse exp)
  (match exp
    [(regexp #rx"Create paragraph .*") (create-paragraph (foldl build-string-w-spaces "" (extract-text-from-create-paragraph-call exp)))]
    [_ (error 'parse "unable to parse ~a" exp)]))

;; interp : exp -> string
;; consumes an exp and returns a HTML component in a string
(define (interp the-exp)
  ; We're consuming an AE, which leads directly to a natural template
  ; and at least some of our tests.
  (type-case exp the-exp
    [create-paragraph (s) (string-append "<p>" (string-append s "</p>"))])
  )

;; TODO: Tests for parse, interp and helpers


;; interpret-user-input () -> string
;; Produces the HTML to be generated from the user input
(define (interpret-user-input)
  (interp (parse (read-user-input (get-input-file)))))

;; run : () -> void
;; Processes the user input in sample.txt by parsing and interpreting it and generating an
;; HTML component. Then, creates sample.html, a file containing the generated HTML
(define (run)
  (close-output-port
   (write-end-html-to-output-file
    (write-body-to-output-file
     (interpret-user-input)
     (write-start-html-to-output-file
      (create-html-file))))))